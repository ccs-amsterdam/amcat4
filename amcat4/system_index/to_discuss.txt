

Dilemma for how to best set up the system index.

We want to make sure that we control the index mapping in the systems index.
One way is to specify the exact mapping, including all subfields.
This is very rigid, and means that we have to update the mapping every time we add a new field.
Alternatively, we can specify only the top-level fields, and use pydantic models for
sub fields, which we then type as 'flattened'. This way elastic indexes the entire object as a single field, and doesn't type the subfields. This way the pydantic model is the source of truth for the subfields, and we don't have to update the mapping every time we add a new field.

maybe we don't need 'flattened'. the normal 'object' is better for searching. But I don't know whether there might be mapping conflicts despite the pydantic model. e.g. could it type a number as integer first, in which case a later float would cause a conflict?


... need to rething a lot of stuff, because pydantic models are not as powerfull as I thought.

Maybe just make the validation for the system index always partial by making all fields optional. It's the responsibility of the helper functions to make sure that the right fields are set. The models are just there to make sure that the fields that are set are of the right type.



options:
- Raw define elastic mapping. No type hints, but typesafety on index. Need to set strict manually
- define elastic mapping with base model. Auto set strict, but still no typesafety
- define pydantic model and infer elastic mapping from that. Typesafe, but don't like that elastic mapping is inferred and not explicit. Also, syncing with models.py gets messy

... we can infer the pydantic model from elastic (already did this), but doesn't work with type hints, so not sure if its of any use then.
